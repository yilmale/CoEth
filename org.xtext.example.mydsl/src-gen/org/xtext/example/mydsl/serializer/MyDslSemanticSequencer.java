/*
 * generated by Xtext 2.9.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Agent;
import org.xtext.example.mydsl.myDsl.CoEthDSL;
import org.xtext.example.mydsl.myDsl.Compete;
import org.xtext.example.mydsl.myDsl.Contradict;
import org.xtext.example.mydsl.myDsl.Deduce;
import org.xtext.example.mydsl.myDsl.Explain;
import org.xtext.example.mydsl.myDsl.Facilitate;
import org.xtext.example.mydsl.myDsl.Feature;
import org.xtext.example.mydsl.myDsl.Incompatible;
import org.xtext.example.mydsl.myDsl.Inhibit;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Similar;
import org.xtext.example.mydsl.myDsl.Trigger;
import org.xtext.example.mydsl.myDsl.ecoNode;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ACTION:
				sequence_Action(context, (org.xtext.example.mydsl.myDsl.Action) semanticObject); 
				return; 
			case MyDslPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case MyDslPackage.CO_ETH_DSL:
				sequence_CoEthDSL(context, (CoEthDSL) semanticObject); 
				return; 
			case MyDslPackage.COMPETE:
				if (rule == grammarAccess.getCompeteRule()) {
					sequence_Compete(context, (Compete) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Compete_ecoConstraint(context, (Compete) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.CONTRADICT:
				if (rule == grammarAccess.getContradictRule()) {
					sequence_Contradict(context, (Contradict) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Contradict_ecoConstraint(context, (Contradict) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.DEDUCE:
				if (rule == grammarAccess.getDeduceRule()) {
					sequence_Deduce(context, (Deduce) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Deduce_ecoConstraint(context, (Deduce) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.EXPLAIN:
				if (rule == grammarAccess.getExplainRule()) {
					sequence_Explain(context, (Explain) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Explain_ecoConstraint(context, (Explain) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.FACILITATE:
				if (rule == grammarAccess.getFacilitateRule()) {
					sequence_Facilitate(context, (Facilitate) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Facilitate_ecoConstraint(context, (Facilitate) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case MyDslPackage.INCOMPATIBLE:
				if (rule == grammarAccess.getIncompatibleRule()) {
					sequence_Incompatible(context, (Incompatible) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Incompatible_ecoConstraint(context, (Incompatible) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.INHIBIT:
				if (rule == grammarAccess.getInhibitRule()) {
					sequence_Inhibit(context, (Inhibit) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Inhibit_ecoConstraint(context, (Inhibit) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.SIMILAR:
				if (rule == grammarAccess.getSimilarRule()) {
					sequence_Similar(context, (Similar) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Similar_ecoConstraint(context, (Similar) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.TRIGGER:
				if (rule == grammarAccess.getTriggerRule()) {
					sequence_Trigger(context, (Trigger) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEcoConstraintRule()) {
					sequence_Trigger_ecoConstraint(context, (Trigger) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.ECO_NODE:
				sequence_ecoNode(context, (ecoNode) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (name=ID aDefinition=STRING)
	 */
	protected void sequence_Action(ISerializationContext context, org.xtext.example.mydsl.myDsl.Action semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ACTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ACTION__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ACTION__ADEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ACTION__ADEFINITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getActionAccess().getADefinitionSTRINGTerminalRuleCall_3_1_0(), semanticObject.getADefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (name=ID features+=Feature* operations+=Action* decoNodes+=ecoNode+ constraints+=ecoConstraint+)
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CoEthDSL returns CoEthDSL
	 *
	 * Constraint:
	 *     (modelName=ID entities+=Agent*)
	 */
	protected void sequence_CoEthDSL(ISerializationContext context, CoEthDSL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Compete returns Compete
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Compete(ISerializationContext context, Compete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Compete
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Compete_ecoConstraint(ISerializationContext context, Compete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contradict returns Contradict
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Contradict(ISerializationContext context, Contradict semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Contradict
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Contradict_ecoConstraint(ISerializationContext context, Contradict semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Deduce returns Deduce
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Deduce(ISerializationContext context, Deduce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Deduce
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Deduce_ecoConstraint(ISerializationContext context, Deduce semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Explain returns Explain
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Explain(ISerializationContext context, Explain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Explain
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Explain_ecoConstraint(ISerializationContext context, Explain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Facilitate returns Facilitate
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Facilitate(ISerializationContext context, Facilitate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Facilitate
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Facilitate_ecoConstraint(ISerializationContext context, Facilitate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (name=ID type=ID)
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FEATURE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FEATURE__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FEATURE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FEATURE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFeatureAccess().getTypeIDTerminalRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Incompatible returns Incompatible
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Incompatible(ISerializationContext context, Incompatible semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Incompatible
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Incompatible_ecoConstraint(ISerializationContext context, Incompatible semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Inhibit returns Inhibit
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Inhibit(ISerializationContext context, Inhibit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Inhibit
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Inhibit_ecoConstraint(ISerializationContext context, Inhibit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Similar returns Similar
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Similar(ISerializationContext context, Similar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Similar
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Similar_ecoConstraint(ISerializationContext context, Similar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE?)
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoConstraint returns Trigger
	 *
	 * Constraint:
	 *     (source=[ecoNode|ID] target=[ecoNode|ID] weight=DOUBLE? cooperativeUnits+=[ecoNode|ID]*)
	 */
	protected void sequence_Trigger_ecoConstraint(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ecoNode returns ecoNode
	 *
	 * Constraint:
	 *     (
	 *         (nType=NodeType name=ID nDefinition=STRING activationLevel=DOUBLE? priority=INT?) | 
	 *         (nType=NodeType name=ID myAction=[Action|ID] bDefinition=STRING)
	 *     )
	 */
	protected void sequence_ecoNode(ISerializationContext context, ecoNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
